#Muhammed Anwar, 998950470, muhammed.anwar@mail.utoronto.ca
#Shaham Farooq, ########, ##################### //Add information here

The simple shell created for lab 1 is meant to provide a basic command prompt user-interface for interacting with the Linux operating system. It allows for traditional system calls including directory changing, and executing new processes. Furthermore it provides user features such as a command history and a path search variable. The following few paragraphs will briefly explain how these features were implemented.

Upon starting the shell, the user will be presented with a simple prompt "ece353sh:". The current directory of the shell can be changed by typing "cd" followed by the directory the user wants to change to. This works by parsing the command entered in the command prompt, checking to see if it was "cd", and then making a system call "chdir()", to change the current working directory. 

The user can also execute a binary file by simply typing in the name of the file prefaced with a "./", assuming the program is in the current directory. The user can also pass in a maximum of 20 arguments to the program by separating them with a white space. This works by calling the "execv()" system call. The parameters to the system call include the path of the executable and the arguments in a string array. These parameters are again found by parsing the user input from the command prompt and storing it accordingly in a simple fixed sized string array. Before execv() can be called another system call to "fork()" must be made. This creates a duplicate child process, where "execv()" replaces the executing code of the child to the program that the user wants to execute. If the file cannot be found, or doesn't execute properly a call to "exit()" is made to quit from the newly forked child process. If the execv() command worked then the parent process (the shell) will wait for the child to finish by making a system call to "waitpid()". 

The shell also provides user features including a history and path search variable. The history is implemented as a simple linked list. Any command typed will be stored in the history in the order that they are input. The user can execute any previous command by typing "!n" where n is the nth command in the history. The user can also display the history by typing "history" in the input. The history stores a maximum of 100 nodes and will remove the oldest nodes as the size limit is passed. The linked list is implemented using two structures "listNode" and "linkedList". The listNode contains the command and the next node. The linkedList has a pointer to the front and end of the list as well as the current size. Together these two structures give a very efficient way of implementing the history with O(1) insertion and deletion with O(n) indexing and searching. 

The final feature of the shell is a path search variable. The user can add to the path many directories. Upon calling the execution of a program the shell will search all the directories in the path and execute the program if found. The user can append to the path variable by "path + some/dir", remove from the path variable by "path - some/dir" and print the path by typing "path". If the use wants to add the current directory to the path they can type "path + ./". The path is implemented using a dynamic string array. Each time a path is added to the array, it reallocates memory for the new element using "realloc()", and adds the element to the end of the array. The dynamic array also keeps track of its size. When executing a program, the contents of the array are looped over and concatenated to the command, which is then passed to "execv()". 

That concludes the brief description of the shell and its features.